/**
 * meshoptimizer - version 0.18
 *
 * Copyright (C) 2016-2022, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at https://github.com/zeux/meshoptimizer
 *
 * This library is distributed under the MIT License. See notice at the end of this file.
 */

/* Experimental APIs have unstable interface and might have implementation that's not fully tested or optimized */
#module_parameters(MESHOPTIMIZER_EXPERIMENTAL := false);

/* Version macro; major * 1000 + minor * 10 + patch */
MESHOPTIMIZER_VERSION :: 180; /* 0.18 */

/**
 * Vertex attribute stream, similar to glVertexPointer
 * Each element takes size bytes, with stride controlling the spacing between successive elements.
 */
meshopt_Stream :: struct
{
	data: *void;
	size: u64;
	stride: u64;
}

/**
 * Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 * Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_generateVertexRemap :: (destination: *u32, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 * To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream.
 * Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_generateVertexRemapMulti :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, streams: *meshopt_Stream, stream_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap
 *
 * destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)
 * vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap
 */
meshopt_remapVertexBuffer :: (destination: *void, vertices: *void, vertex_count: u64, vertex_size: u64, remap: *u32) #foreign meshopt_lib;

/**
 * Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_remapIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, remap: *u32) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
 * All vertices that are binary equivalent (wrt first vertex_size bytes) map to the first vertex in the original vertex buffer.
 * This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
 * Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_generateShadowIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64, vertex_stride: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
 * All vertices that are binary equivalent (wrt specified streams) map to the first vertex in the original vertex buffer.
 * This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
 * Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_generateShadowIndexBufferMulti :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, streams: *meshopt_Stream, stream_count: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used as a geometry shader input with triangle adjacency topology
 * Each triangle is converted into a 6-vertex patch with the following layout:
 * - 0, 2, 4: original triangle vertices
 * - 1, 3, 5: vertices adjacent to edges 02, 24 and 40
 * The resulting patch can be rendered with geometry shaders using e.g. VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY.
 * This can be used to implement algorithms like silhouette detection/expansion and other forms of GS-driven rendering.
 *
 * destination must contain enough space for the resulting index buffer (index_count*2 elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 */
meshopt_generateAdjacencyIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for PN-AEN tessellation with crack-free displacement
 * Each triangle is converted into a 12-vertex patch with the following layout:
 * - 0, 1, 2: original triangle vertices
 * - 3, 4: opposing edge for edge 0, 1
 * - 5, 6: opposing edge for edge 1, 2
 * - 7, 8: opposing edge for edge 2, 0
 * - 9, 10, 11: dominant vertices for corners 0, 1, 2
 * The resulting patch can be rendered with hardware tessellation using PN-AEN and displacement mapping.
 * See "Tessellation on Any Budget" (John McDonald, GDC 2011) for implementation details.
 *
 * destination must contain enough space for the resulting index buffer (index_count*4 elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 */
meshopt_generateTessellationIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer
 * Reorders indices to reduce the number of GPU vertex shader invocations
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_optimizeVertexCache :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer for strip-like caches
 * Produces inferior results to meshopt_optimizeVertexCache from the GPU vertex cache perspective
 * However, the resulting index order is more optimal if the goal is to reduce the triangle strip length or improve compression efficiency
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_optimizeVertexCacheStrip :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer for FIFO caches
 * Reorders indices to reduce the number of GPU vertex shader invocations
 * Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * cache_size should be less than the actual GPU cache size to avoid cache thrashing
 */
meshopt_optimizeVertexCacheFifo :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, cache_size: u32) #foreign meshopt_lib;

/**
 * Overdraw optimizer
 * Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * indices must contain index data that is the result of meshopt_optimizeVertexCache (*not* the original mesh indices!)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 * threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently
 */
meshopt_optimizeOverdraw :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, threshold: float32) #foreign meshopt_lib;

/**
 * Vertex fetch cache optimizer
 * Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing
 * Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
 * This functions works for a single vertex stream; for multiple vertex streams, use meshopt_optimizeVertexFetchRemap + meshopt_remapVertexBuffer for each stream.
 *
 * destination must contain enough space for the resulting vertex buffer (vertex_count elements)
 * indices is used both as an input and as an output index buffer
 */
meshopt_optimizeVertexFetch :: (destination: *void, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Vertex fetch cache optimizer
 * Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing
 * Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
 * The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 */
meshopt_optimizeVertexFetchRemap :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Index buffer encoder
 * Encodes index data into an array of bytes that is generally much smaller (<1.5 bytes/triangle) and compresses better (<1 bytes/triangle) compared to original.
 * Input index buffer must represent a triangle list.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 * For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first.
 *
 * buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to compute worst case size)
 */
meshopt_encodeIndexBuffer :: (buffer: *u8, buffer_size: u64, indices: *u32, index_count: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeIndexBufferBound :: (index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Set index encoder format version
 * version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.14+)
 */
meshopt_encodeIndexVersion :: (version: s32) #foreign meshopt_lib;

/**
 * Index buffer decoder
 * Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_decodeIndexBuffer :: (destination: *void, index_count: u64, index_size: u64, buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

/**
 * Index sequence encoder
 * Encodes index sequence into an array of bytes that is generally smaller and compresses better compared to original.
 * Input index sequence can represent arbitrary topology; for triangle lists meshopt_encodeIndexBuffer is likely to be better.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 *
 * buffer must contain enough space for the encoded index sequence (use meshopt_encodeIndexSequenceBound to compute worst case size)
 */
meshopt_encodeIndexSequence :: (buffer: *u8, buffer_size: u64, indices: *u32, index_count: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeIndexSequenceBound :: (index_count: u64, vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Index sequence decoder
 * Decodes index data from an array of bytes generated by meshopt_encodeIndexSequence
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
 *
 * destination must contain enough space for the resulting index sequence (index_count elements)
 */
meshopt_decodeIndexSequence :: (destination: *void, index_count: u64, index_size: u64, buffer: *u8, buffer_size: u64) -> s64 #foreign meshopt_lib;

/**
 * Vertex buffer encoder
 * Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 * This function works for a single vertex stream; for multiple vertex streams, call meshopt_encodeVertexBuffer for each stream.
 * Note that all vertex_size bytes of each vertex are encoded verbatim, including padding which should be zero-initialized.
 *
 * buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to compute worst case size)
 */
meshopt_encodeVertexBuffer :: (buffer: *u8, buffer_size: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeVertexBufferBound :: (vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Set vertex encoder format version
 * version must specify the data format version to encode; valid values are 0 (decodable by all library versions)
 */
meshopt_encodeVertexVersion :: (version: s32) #foreign meshopt_lib;

/**
 * Vertex buffer decoder
 * Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data.
 *
 * destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)
 */
meshopt_decodeVertexBuffer :: (destination: *void, vertex_count: u64, vertex_size: u64, buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Vertex buffer filters
	 * These functions can be used to filter output of meshopt_decodeVertexBuffer in-place.
	 *
	 * meshopt_decodeFilterOct decodes octahedral encoding of a unit vector with K-bit (K <= 16) signed X/Y as an input; Z must store 1.0f.
	 * Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.
	 *
	 * meshopt_decodeFilterQuat decodes 3-component quaternion encoding with K-bit (4 <= K <= 16) component encoding and a 2-bit component index indicating which component to reconstruct.
	 * Each component is stored as an 16-bit integer; stride must be equal to 8.
	 *
	 * meshopt_decodeFilterExp decodes exponential encoding of floating-point data with 8-bit exponent and 24-bit integer mantissa as 2^E*M.
	 * Each 32-bit component is decoded in isolation; stride must be divisible by 4.
	 */
	meshopt_decodeFilterOct :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;
	meshopt_decodeFilterQuat :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;
	meshopt_decodeFilterExp :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;

	/**
	 * Vertex buffer filter encoders
	 * These functions can be used to encode data in a format that meshopt_decodeFilter can decode
	 *
	 * meshopt_encodeFilterOct encodes unit vectors with K-bit (K <= 16) signed X/Y as an output.
	 * Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.
	 * Input data must contain 4 floats for every vector (count*4 total).
	 *
	 * meshopt_encodeFilterQuat encodes unit quaternions with K-bit (4 <= K <= 16) component encoding.
	 * Each component is stored as an 16-bit integer; stride must be equal to 8.
	 * Input data must contain 4 floats for every quaternion (count*4 total).
	 *
	 * meshopt_encodeFilterExp encodes arbitrary (finite) floating-point data with 8-bit exponent and K-bit integer mantissa (1 <= K <= 24).
	 * Mantissa is shared between all components of a given vector as defined by stride; stride must be divisible by 4.
	 * Input data must contain stride/4 floats for every vector (count*stride/4 total).
	 * When individual (scalar) encoding is desired, simply pass stride=4 and adjust count accordingly.
	 */
	meshopt_encodeFilterOct :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32) #foreign meshopt_lib;
	meshopt_encodeFilterQuat :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32) #foreign meshopt_lib;
	meshopt_encodeFilterExp :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32) #foreign meshopt_lib;
}

/**
 * Mesh simplifier
 * Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible
 * The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
 * If not all attributes from the input mesh are required, it's recommended to reindex the mesh using meshopt_generateShadowIndexBuffer prior to simplification.
 * Returns the number of indices after simplification, with destination containing new index data
 * The resulting index buffer references vertices from the original vertex buffer.
 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
 *
 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation
 * options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
 */
meshopt_simplify :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_index_count: u64, target_error: float32, options: u32, result_error: *float32) -> u64 #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Experimental: Mesh simplifier (sloppy)
	 * Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance
	 * The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error.
	 * Returns the number of indices after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
	 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation
	 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
	 */
	meshopt_simplifySloppy :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_index_count: u64, target_error: float32, result_error: *float32) -> u64 #foreign meshopt_lib;

	/**
	 * Experimental: Point cloud simplifier
	 * Reduces the number of points in the cloud to reach the given target
	 * Returns the number of points after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer (target_vertex_count elements)
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
	 */
	meshopt_simplifyPoints :: (destination: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_vertex_count: u64) -> u64 #foreign meshopt_lib;
}

/**
 * Returns the error scaling factor used by the simplifier to convert between absolute and relative extents
 *
 * Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error
 * Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error.
 */
meshopt_simplifyScale :: (vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> float32 #foreign meshopt_lib;

/**
 * Mesh stripifier
 * Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index or degenerate triangles
 * Returns the number of indices in the resulting strip, with destination containing new index data
 * For maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
 * Using restart indices can result in ~10% smaller index buffers, but on some GPUs restart indices may result in decreased performance.
 *
 * destination must contain enough space for the target index buffer, worst case can be computed with meshopt_stripifyBound
 * restart_index should be 0xffff or 0xffffffff depending on index size, or 0 to use degenerate triangles
 */
meshopt_stripify :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, restart_index: u32) -> u64 #foreign meshopt_lib;
meshopt_stripifyBound :: (index_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Mesh unstripifier
 * Converts a triangle strip to a triangle list
 * Returns the number of indices in the resulting list, with destination containing new index data
 *
 * destination must contain enough space for the target index buffer, worst case can be computed with meshopt_unstripifyBound
 */
meshopt_unstripify :: (destination: *u32, indices: *u32, index_count: u64, restart_index: u32) -> u64 #foreign meshopt_lib;
meshopt_unstripifyBound :: (index_count: u64)-> u64 #foreign meshopt_lib;

meshopt_VertexCacheStatistics :: struct
{
	vertices_transformed: u32;
	warps_executed: u32;
	acmr: float32; /* transformed vertices / triangle count; best case 0.5, worst case 3.0, optimum depends on topology */
	atvr: float32; /* transformed vertices / vertex count; best case 1.0, worst case 6.0, optimum is 1.0 (each vertex is transformed once) */
}

/**
 * Vertex transform cache analyzer
 * Returns cache hit statistics using a simplified FIFO model
 * Results may not match actual GPU performance
 */
meshopt_analyzeVertexCache :: (indices: *u32, index_count: u64, vertex_count: u64, cache_size: u32, warp_size: u32, primgroup_size: u32) -> meshopt_VertexCacheStatistics #foreign meshopt_lib;

meshopt_OverdrawStatistics :: struct
{
	pixels_covered: u32;
	pixels_shaded: u32;
	overdraw: float32; /* shaded pixels / covered pixels; best case 1.0 */
}

/**
 * Overdraw analyzer
 * Returns overdraw statistics using a software rasterizer
 * Results may not match actual GPU performance
 *
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 */
meshopt_analyzeOverdraw :: (indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_OverdrawStatistics #foreign meshopt_lib;

meshopt_VertexFetchStatistics :: struct
{
	bytes_fetched: u32;
	overfetch: float32; /* fetched bytes / vertex buffer size; best case 1.0 (each byte is fetched once) */
}

/**
 * Vertex fetch cache analyzer
 * Returns cache hit statistics using a simplified direct mapped model
 * Results may not match actual GPU performance
 */
meshopt_analyzeVertexFetch :: (indices: *u32, index_count: u64, vertex_count: u64, vertex_size: u64) -> meshopt_VertexFetchStatistics #foreign meshopt_lib;

meshopt_Meshlet :: struct
{
	/* offsets within meshlet_vertices and meshlet_triangles arrays with meshlet data */
	vertex_offset: u32;
	triangle_offset: u32;

	/* number of vertices and triangles used in the meshlet; data is stored in consecutive range defined by offset and count */
	vertex_count: u32;
	triangle_count: u32;
}

/**
 * Meshlet builder
 * Splits the mesh into a set of meshlets where each meshlet has a micro index buffer indexing into meshlet vertices that refer to the original vertex buffer
 * The resulting data can be used to render meshes using NVidia programmable mesh shading pipeline, or in other cluster-based renderers.
 * When using buildMeshlets, vertex positions need to be provided to minimize the size of the resulting clusters.
 * When using buildMeshletsScan, for maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
 *
 * meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound
 * meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
 * meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 * max_vertices and max_triangles must not exceed implementation limits (max_vertices <= 255 - not 256!, max_triangles <= 512)
 * cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency
 */
meshopt_buildMeshlets :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, max_vertices: u64, max_triangles: u64, cone_weight: float32) -> u64 #foreign meshopt_lib;
meshopt_buildMeshletsScan :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_count: u64, max_vertices: u64, max_triangles: u64) -> u64 #foreign meshopt_lib;
meshopt_buildMeshletsBound :: (index_count: u64, max_vertices: u64, max_triangles: u64) -> u64 #foreign meshopt_lib;

meshopt_Bounds :: struct
{
	/* bounding sphere, useful for frustum and occlusion culling */
	center: [3]float32;
	radius: float32;

	/* normal cone, useful for backface culling */
	cone_apex: [3]float32;
	cone_axis: [3]float32;
	cone_cutoff: float32; /* = cos(angle/2) */

	/* normal cone axis and cutoff, stored in 8-bit SNORM format; decode using x/127.0 */
	cone_axis_s8: [3]s8;
	cone_cutoff_s8: s8;
}

/**
 * Cluster bounds generator
 * Creates bounding volumes that can be used for frustum, backface and occlusion culling.
 *
 * For backface culling with orthographic projection, use the following formula to reject backfacing clusters:
 *   dot(view, cone_axis) >= cone_cutoff
 *
 * For perspective projection, you can the formula that needs cone apex in addition to axis & cutoff:
 *   dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff
 *
 * Alternatively, you can use the formula that doesn't need cone apex and uses bounding sphere instead:
 *   dot(normalize(center - camera_position), cone_axis) >= cone_cutoff + radius / length(center - camera_position)
 * or an equivalent formula that doesn't have a singularity at center = camera_position:
 *   dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius
 *
 * The formula that uses the apex is slightly more accurate but needs the apex; if you are already using bounding sphere
 * to do frustum/occlusion culling, the formula that doesn't use the apex may be preferable.
 *
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 * index_count/3 should be less than or equal to 512 (the function assumes clusters of limited size)
 */
meshopt_computeClusterBounds :: (indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_Bounds #foreign meshopt_lib;
meshopt_computeMeshletBounds :: (meshlet_vertices: *u32, meshlet_triangles: *u8, triangle_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_Bounds #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Experimental: Spatial sorter
	 * Generates a remap table that can be used to reorder points for spatial locality.
	 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer.
	 *
	 * destination must contain enough space for the resulting remap table (vertex_count elements)
	 */
	meshopt_spatialSortRemap :: (destination: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

	/**
	 * Experimental: Spatial sorter
	 * Reorders triangles for spatial locality, and generates a new index buffer. The resulting index buffer can be used with other functions like optimizeVertexCache.
	 *
	 * destination must contain enough space for the resulting index buffer (index_count elements)
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
	 */
	meshopt_spatialSortTriangles :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;
}

/**
 * Set allocation callbacks
 * These callbacks will be used instead of the default operator new/operator delete for all temporary allocations in the library.
 * Note that all algorithms only allocate memory for temporary use.
 * allocate/deallocate are always called in a stack-like order - last pointer to be allocated is deallocated first.
 */
meshopt_setAllocator :: (allocate: #type (size: u64) -> *void #c_call, deallocate: #type (ptr: *void) #c_call) #foreign meshopt_lib;

/**
 * Quantize a float in [0..1] range into an N-bit fixed point unorm value
 * Assumes reconstruction function (q / (2^N-1)), which is the case for fixed-function normalized fixed point conversion
 * Maximum reconstruction error: 1/2^(N+1)
 */
meshopt_quantizeUnorm :: inline (v: float32, N: s32) -> u32
{
	scale := cast(float32)((1 << N) - 1);

	v = ifx (v >= 0) v else 0;
	v = ifx (v <= 1) v else 1;

	return cast(u32)(v * scale + 0.5);
}

/**
 * Quantize a float in [-1..1] range into an N-bit fixed point snorm value
 * Assumes reconstruction function (q / (2^(N-1)-1)), which is the case for fixed-function normalized fixed point conversion (except early OpenGL versions)
 * Maximum reconstruction error: 1/2^N
 */
meshopt_quantizeSnorm :: inline (v: float32, N: s32) -> s32
{
	scale := cast(float)((1 << (N - 1)) - 1);

	round := ifx (v >= 0) 0.5 else -0.5;

	v = ifx (v >= -1) v else -1;
	v = ifx (v <= +1) v else +1;

	return cast(s32)(v * scale + round);
}

/**
 * Quantize a float into half-precision floating point value
 * Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
 * Representable magnitude range: [6e-5; 65504]
 * Maximum relative reconstruction error: 5e-4
 */
meshopt_quantizeHalf :: inline (v: float32) -> u16
{
	u: union { f: float32; ui: u32; } = ---;
	u.f = v;
	ui := u.ui;

	s := cast(s32)((ui >> 16) & 0x8000);
	em := cast(s32)(ui & 0x7fffffff);

	/* bias exponent and round to nearest; 112 is relative exponent bias (127-15) */
	h := (em - (112 << 23) + (1 << 12)) >> 13;

	/* underflow: flush to zero; 113 encodes exponent -14 */
	h = ifx (em < (113 << 23)) 0 else h;

	/* overflow: infinity; 143 encodes exponent 16 */
	h = ifx (em >= (143 << 23)) 0x7c00 else h;

	/* NaN; note that we convert all types of NaN to qNaN */
	h = ifx (em > (255 << 23)) 0x7e00 else h;

	return cast(u16)(s | h);
}

/**
 * Quantize a float into a floating point value with a limited number of significant mantissa bits
 * Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
 * Assumes N is in a valid mantissa precision range, which is 1..23
 */
meshopt_quantizeFloat :: inline (v: float32, N: s32) -> float32
{
	u: union { f: float32; ui: u32; } = ---;
	u.f = v;
	ui := u.ui;

	mask := cast(u32)((1 << (23 - N)) - 1);
	round := cast(u32)((1 << (23 - N)) >> 1);

	e := ui & 0x7f800000;
	rui := (ui + round) & ~mask;

	/* round all numbers except inf/nan; this is important to make sure nan doesn't overflow into -0 */
	ui = ifx (e == 0x7f800000) ui else rui;

	/* flush denormals to zero */
	ui = ifx (e == 0) 0 else ui;

	u.ui = ui;
	return u.f;
}

#scope_file

#if OS == .WINDOWS  meshopt_lib :: #foreign_library,no_dll "win/meshoptimizer";
#if OS == .MACOS    meshopt_lib :: #foreign_library,no_dll "macos/meshoptimizer";
#if OS == .LINUX    meshopt_lib :: #foreign_library,no_dll "linux/meshoptimizer";