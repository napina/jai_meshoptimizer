/**
 * meshoptimizer - version 0.25
 *
 * Copyright (C) 2016-2025, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at https://github.com/zeux/meshoptimizer
 *
 * This library is distributed under the MIT License. See notice at the end of this file.
 */

/* Experimental APIs have unstable interface and might have implementation that's not fully tested or optimized */
#module_parameters(MESHOPTIMIZER_EXPERIMENTAL := false);

/* Version macro; major * 1000 + minor * 10 + patch */
MESHOPTIMIZER_VERSION :: 250; /* 0.25 */

/**
 * Vertex attribute stream
 * Each element takes size bytes, beginning at data, with stride controlling the spacing between successive elements (stride >= size).
 */
meshopt_Stream :: struct
{
	data: *void;
	size: u64;
	stride: u64;
}

/**
 * Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 * Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_generateVertexRemap :: (destination: *u32, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 * To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream.
 * Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_generateVertexRemapMulti :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, streams: *meshopt_Stream, stream_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Equivalence is checked in two steps: vertex positions are compared for equality, and then the user-specified equality function is called (if provided).
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * callback can be NULL if no additional equality check is needed; otherwise, it should return 1 if vertices with specified indices are equivalent and 0 if they are not
 */
meshopt_generateVertexRemapCustom_callback :: #type (userdata: *void, a: u32, b: u32) -> s32 #c_call;
meshopt_generateVertexRemapCustom :: (destination: *u32, indices: *u32, index_count: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, callback: meshopt_generateVertexRemapCustom_callback, userdata: *void) -> u64 #foreign meshopt_lib;

/**
 * Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap
 *
 * destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)
 * vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap
 */
meshopt_remapVertexBuffer :: (destination: *void, vertices: *void, vertex_count: u64, vertex_size: u64, remap: *u32) #foreign meshopt_lib;

/**
 * Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * indices can be NULL if the input is unindexed
 */
meshopt_remapIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, remap: *u32) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
 * All vertices that are binary equivalent (wrt first vertex_size bytes) map to the first vertex in the original vertex buffer.
 * This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
 * Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_generateShadowIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64, vertex_stride: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
 * All vertices that are binary equivalent (wrt specified streams) map to the first vertex in the original vertex buffer.
 * This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
 * Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_generateShadowIndexBufferMulti :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, streams: *meshopt_Stream, stream_count: u64) #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Experimental: Generates a remap table that maps all vertices with the same position to the same (existing) index.
	 * Similarly to meshopt_generateShadowIndexBuffer, this can be helpful to pre-process meshes for position-only rendering.
	 * This can also be used to implement algorithms that require positional-only connectivity, such as hierarchical simplification.
	 *
	 * destination must contain enough space for the resulting remap table (vertex_count elements)
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 */
	meshopt_generatePositionRemap :: (destination: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;
}

/**
 * Generate index buffer that can be used as a geometry shader input with triangle adjacency topology
 * Each triangle is converted into a 6-vertex patch with the following layout:
 * - 0, 2, 4: original triangle vertices
 * - 1, 3, 5: vertices adjacent to edges 02, 24 and 40
 * The resulting patch can be rendered with geometry shaders using e.g. VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY.
 * This can be used to implement algorithms like silhouette detection/expansion and other forms of GS-driven rendering.
 *
 * destination must contain enough space for the resulting index buffer (index_count*2 elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 */
meshopt_generateAdjacencyIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for PN-AEN tessellation with crack-free displacement
 * Each triangle is converted into a 12-vertex patch with the following layout:
 * - 0, 1, 2: original triangle vertices
 * - 3, 4: opposing edge for edge 0, 1
 * - 5, 6: opposing edge for edge 1, 2
 * - 7, 8: opposing edge for edge 2, 0
 * - 9, 10, 11: dominant vertices for corners 0, 1, 2
 * The resulting patch can be rendered with hardware tessellation using PN-AEN and displacement mapping.
 * See "Tessellation on Any Budget" (John McDonald, GDC 2011) for implementation details.
 *
 * destination must contain enough space for the resulting index buffer (index_count*4 elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 */
meshopt_generateTessellationIndexBuffer :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Generate index buffer that can be used for visibility buffer rendering and returns the size of the reorder table
 * Each triangle's provoking vertex index is equal to primitive id; this allows passing it to the fragment shader using flat/nointerpolate attribute.
 * This is important for performance on hardware where primitive id can't be accessed efficiently in fragment shader.
 * The reorder table stores the original vertex id for each vertex in the new index buffer, and should be used in the vertex shader to load vertex data.
 * The provoking vertex is assumed to be the first vertex in the triangle; if this is not the case (OpenGL), rotate each triangle (abc -> bca) before rendering.
 * For maximum efficiency the input index buffer should be optimized for vertex cache first.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * reorder must contain enough space for the worst case reorder table (vertex_count + index_count/3 elements)
 */
meshopt_generateProvokingIndexBuffer :: (destination: *u32, reorder: *u32, indices: *u32, index_count: u64, vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer
 * Reorders indices to reduce the number of GPU vertex shader invocations
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_optimizeVertexCache :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer for strip-like caches
 * Produces inferior results to meshopt_optimizeVertexCache from the GPU vertex cache perspective
 * However, the resulting index order is more optimal if the goal is to reduce the triangle strip length or improve compression efficiency
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_optimizeVertexCacheStrip :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Vertex transform cache optimizer for FIFO caches
 * Reorders indices to reduce the number of GPU vertex shader invocations
 * Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * cache_size should be less than the actual GPU cache size to avoid cache thrashing
 */
meshopt_optimizeVertexCacheFifo :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, cache_size: u32) #foreign meshopt_lib;

/**
 * Overdraw optimizer
 * Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw
 * If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * indices must contain index data that is the result of meshopt_optimizeVertexCache (*not* the original mesh indices!)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex - similar to glVertexPointer
 * threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently
 */
meshopt_optimizeOverdraw :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, threshold: float32) #foreign meshopt_lib;

/**
 * Vertex fetch cache optimizer
 * Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing
 * Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
 * This functions works for a single vertex stream; for multiple vertex streams, use meshopt_optimizeVertexFetchRemap + meshopt_remapVertexBuffer for each stream.
 *
 * destination must contain enough space for the resulting vertex buffer (vertex_count elements)
 * indices is used both as an input and as an output index buffer
 */
meshopt_optimizeVertexFetch :: (destination: *void, indices: *u32, index_count: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Vertex fetch cache optimizer
 * Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing
 * Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
 * The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 */
meshopt_optimizeVertexFetchRemap :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Index buffer encoder
 * Encodes index data into an array of bytes that is generally much smaller (<1.5 bytes/triangle) and compresses better (<1 bytes/triangle) compared to original.
 * Input index buffer must represent a triangle list.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 * For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first.
 *
 * buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to compute worst case size)
 */
meshopt_encodeIndexBuffer :: (buffer: *u8, buffer_size: u64, indices: *u32, index_count: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeIndexBufferBound :: (index_count: u64, vertex_count: u64) #foreign meshopt_lib;

/**
 * Set index encoder format version
 * version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.14+)
 */
meshopt_encodeIndexVersion :: (version: s32) #foreign meshopt_lib;

/**
 * Index buffer decoder
 * Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 */
meshopt_decodeIndexBuffer :: (destination: *void, index_count: u64, index_size: u64, buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

/**
 * Get encoded index format version
 * Returns format version of the encoded index buffer/sequence, or -1 if the buffer header is invalid
 * Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed.
 */
meshopt_decodeIndexVersion :: (buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

/**
 * Index sequence encoder
 * Encodes index sequence into an array of bytes that is generally smaller and compresses better compared to original.
 * Input index sequence can represent arbitrary topology; for triangle lists meshopt_encodeIndexBuffer is likely to be better.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 *
 * buffer must contain enough space for the encoded index sequence (use meshopt_encodeIndexSequenceBound to compute worst case size)
 */
meshopt_encodeIndexSequence :: (buffer: *u8, buffer_size: u64, indices: *u32, index_count: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeIndexSequenceBound :: (index_count: u64, vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Index sequence decoder
 * Decodes index data from an array of bytes generated by meshopt_encodeIndexSequence
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
 *
 * destination must contain enough space for the resulting index sequence (index_count elements)
 */
meshopt_decodeIndexSequence :: (destination: *void, index_count: u64, index_size: u64, buffer: *u8, buffer_size: u64) -> s64 #foreign meshopt_lib;

/**
 * Vertex buffer encoder
 * Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original.
 * Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
 * This function works for a single vertex stream; for multiple vertex streams, call meshopt_encodeVertexBuffer for each stream.
 * Note that all vertex_size bytes of each vertex are encoded verbatim, including padding which should be zero-initialized.
 *
 * buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to compute worst case size)
 */
meshopt_encodeVertexBuffer :: (buffer: *u8, buffer_size: u64, vertices: *void, vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;
meshopt_encodeVertexBufferBound :: (vertex_count: u64, vertex_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Vertex buffer encoder
 * Encodes vertex data just like meshopt_encodeVertexBuffer, but allows to override compression level.
 * For compression level to take effect, the vertex encoding version must be set to 1.
 * The default compression level implied by meshopt_encodeVertexBuffer is 2.
 *
 * level should be in the range [0, 3] with 0 being the fastest and 3 being the slowest and producing the best compression ratio.
 * version should be -1 to use the default version (specified via meshopt_encodeVertexVersion), or 0/1 to override the version; per above, level won't take effect if version is 0.
 */
meshopt_encodeVertexBufferLevel :: (buffer: *u8, buffer_size: *u64, vertices: *void, vertex_count: u64, vertex_size: u64, level: s32, version: s32) -> u64 #foreign meshopt_lib;

/**
 * Set vertex encoder format version
 * version must specify the data format version to encode; valid values are 0 (decodable by all library versions)
 */
meshopt_encodeVertexVersion :: (version: s32) #foreign meshopt_lib;

/**
 * Vertex buffer decoder
 * Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer
 * Returns 0 if decoding was successful, and an error code otherwise
 * The decoder is safe to use for untrusted input, but it may produce garbage data.
 *
 * destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)
 */
meshopt_decodeVertexBuffer :: (destination: *void, vertex_count: u64, vertex_size: u64, buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

/**
 * Get encoded vertex format version
 * Returns format version of the encoded vertex buffer, or -1 if the buffer header is invalid
 * Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed.
 */
meshopt_decodeVertexVersion :: (buffer: *u8, buffer_size: u64) -> s32 #foreign meshopt_lib;

/**
 * Vertex buffer filters
 * These functions can be used to filter output of meshopt_decodeVertexBuffer in-place.
 *
 * meshopt_decodeFilterOct decodes octahedral encoding of a unit vector with K-bit (K <= 16) signed X/Y as an input; Z must store 1.0f.
 * Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.
 *
 * meshopt_decodeFilterQuat decodes 3-component quaternion encoding with K-bit (4 <= K <= 16) component encoding and a 2-bit component index indicating which component to reconstruct.
 * Each component is stored as an 16-bit integer; stride must be equal to 8.
 *
 * meshopt_decodeFilterExp decodes exponential encoding of floating-point data with 8-bit exponent and 24-bit integer mantissa as 2^E*M.
 * Each 32-bit component is decoded in isolation; stride must be divisible by 4.
 *
 * Experimental: meshopt_decodeFilterColor decodes YCoCg (+A) color encoding where RGB is converted to YCoCg space with variable bit quantization.
 * Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8.
 */
meshopt_decodeFilterOct :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;
meshopt_decodeFilterQuat :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;
meshopt_decodeFilterExp :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	meshopt_decodeFilterColor :: (buffer: *void, count: u64, stride: u64) #foreign meshopt_lib;
}

/**
 * Vertex buffer filter encoders
 * These functions can be used to encode data in a format that meshopt_decodeFilter can decode
 *
 * meshopt_encodeFilterOct encodes unit vectors with K-bit (K <= 16) signed X/Y as an output.
 * Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.
 * Input data must contain 4 floats for every vector (count*4 total).
 *
 * meshopt_encodeFilterQuat encodes unit quaternions with K-bit (4 <= K <= 16) component encoding.
 * Each component is stored as an 16-bit integer; stride must be equal to 8.
 * Input data must contain 4 floats for every quaternion (count*4 total).
 *
 * meshopt_encodeFilterExp encodes arbitrary (finite) floating-point data with 8-bit exponent and K-bit integer mantissa (1 <= K <= 24).
 * Exponent can be shared between all components of a given vector as defined by stride or all values of a given component; stride must be divisible by 4.
 * Input data must contain stride/4 floats for every vector (count*stride/4 total).
 */
meshopt_EncodeExpMode :: enum s32
{
    /* When encoding exponents, use separate values for each component (maximum quality) */
	meshopt_EncodeExpSeparate;
	/* When encoding exponents, use shared value for all components of each vector (better compression) */
	meshopt_EncodeExpSharedVector;
	/* When encoding exponents, use shared value for each component of all vectors (best compression) */
	meshopt_EncodeExpSharedComponent;
	/* Experimental: When encoding exponents, use separate values for each component, but clamp to 0 (good quality if very small values are not important) */
	meshopt_EncodeExpClamped;
}

meshopt_encodeFilterOct :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32) #foreign meshopt_lib;
meshopt_encodeFilterQuat :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32) #foreign meshopt_lib;
meshopt_encodeFilterExp :: (destination: *void, count: u64, stride: u64, bits: s32, data: *float32, mode: meshopt_EncodeExpMode) #foreign meshopt_lib;

/**
 * Simplification options
 */
meshopt_SimplifyOptions :: enum_flags u32
{
	/* Do not move vertices that are located on the topological border (vertices on triangle edges that don't have a paired triangle). Useful for simplifying portions of the larger mesh. */
	meshopt_SimplifyLockBorder :: 1 << 0;
	/* Improve simplification performance assuming input indices are a sparse subset of the mesh. Note that error becomes relative to subset extents. */
	meshopt_SimplifySparse :: 1 << 1;
	/* Treat error limit and resulting error as absolute instead of relative to mesh extents. */
	meshopt_SimplifyErrorAbsolute :: 1 << 2;
	/* Remove disconnected parts of the mesh during simplification incrementally, regardless of the topological restrictions inside components. */
	meshopt_SimplifyPrune :: 1 << 3;
	/* Experimental: Produce more regular triangle sizes and shapes during simplification, at some cost to geometric quality. */
	meshopt_SimplifyRegularize :: 1 << 4;
	/* Experimental: Allow collapses across attribute discontinuities, except for vertices that are tagged with meshopt_SimplifyVertex_Protect in vertex_lock. */
	meshopt_SimplifyPermissive :: 1 << 5;
}

/**
 * Experimental: Simplification vertex flags/locks, for use in `vertex_lock` arrays in simplification APIs
 */
meshopt_VertexLocal :: enum_flags u8
{
	/* Do not move this vertex. */
	meshopt_SimplifyVertex_Lock :: 1 << 0;
	/* Protect attribute discontinuity at this vertex; must be used together with meshopt_SimplifyPermissive option. */
	meshopt_SimplifyVertex_Protect :: 1 << 1;
}

/**
 * Mesh simplifier
 * Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible
 * The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
 * If not all attributes from the input mesh are needed, it's recommended to reindex the mesh without them prior to simplification.
 * Returns the number of indices after simplification, with destination containing new index data
 * The resulting index buffer references vertices from the original vertex buffer.
 * If the original vertex data isn't needed, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
 *
 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
 * options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
 */
meshopt_simplify :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_index_count: u64, target_error: float32, options: u32, result_error: *float32) -> u64 #foreign meshopt_lib;

/**
 * Mesh simplifier with attribute metric
 * Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible.
 * Similar to meshopt_simplify, but incorporates attribute values into the error metric used to prioritize simplification order.
 * The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
 * If not all attributes from the input mesh are needed, it's recommended to reindex the mesh without them prior to simplification.
 * Returns the number of indices after simplification, with destination containing new index data
 *
 * The resulting index buffer references vertices from the original vertex buffer.
 * If the original vertex data isn't needed, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
 * Note that the number of attributes with non-zero weights affects memory requirements and running time.
 *
 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * vertex_attributes should have attribute_count floats for each vertex
 * attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position
 * attribute_count must be <= 32
 * vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved
 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
 * options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
 */
meshopt_simplifyWithAttributes :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, vertex_attributes: *float32, vertex_attributes_stride: u64, attribute_weights: *float32, attribute_count: u64, vertex_lock: *u8, target_index_count: u64, target_error: float32, options: u32, result_error: *float32) -> u64 #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Experimental: Mesh simplifier with position/attribute update
	 * Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible.
	 * Similar to meshopt_simplifyWithAttributes, but destructively updates positions and attribute values for optimal appearance.
	 * The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
	 * If not all attributes from the input mesh are needed, it's recommended to reindex the mesh without them prior to simplification.
	 * Returns the number of indices after simplification, indices are destructively updated with new index data
	 *
	 * The updated index buffer references vertices from the original vertex buffer, however the vertex positions and attributes are updated in-place.
	 * Creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended; if the original vertex data is needed, it should be copied before simplification.
	 * Note that the number of attributes with non-zero weights affects memory requirements and running time. Attributes with zero weights are not updated.
	 *
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * vertex_attributes should have attribute_count floats for each vertex
	 * attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position
	 * attribute_count must be <= 32
	 * vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved
	 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
	 * options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
	 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
	 */
	meshopt_simplifyWithUpdate :: (indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, vertex_attributes: *float32, vertex_attributes_stride: u64, attribute_weights: *float32, attribute_count: u64, vertex_lock: *u8, target_index_count: u64, target_error: float32, options: u32, result_error: *float32) -> u64 #foreign meshopt_lib;

	/**
	 * Experimental: Mesh simplifier (sloppy)
	 * Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance
	 * The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error.
	 * Returns the number of indices after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; vertices that can't be moved should set 1 consistently for all indices with the same position
	 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
	 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
	 */
	meshopt_simplifySloppy :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, vertex_lock: *u8, target_index_count: u64, target_error: float32, result_error: *float32) -> u64 #foreign meshopt_lib;
}

/**
 * Mesh simplifier (pruner)
 * Reduces the number of triangles in the mesh by removing small isolated parts of the mesh
 * Returns the number of indices after simplification, with destination containing new index data
 * The resulting index buffer references vertices from the original vertex buffer.
 * If the original vertex data isn't needed, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
 *
 * destination must contain enough space for the target index buffer, worst case is index_count elements
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
 */
meshopt_simplifyPrune :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_error: float32) -> u64 #foreign meshopt_lib;

/**
 * Point cloud simplifier
 * Reduces the number of points in the cloud to reach the given target
 * Returns the number of points after simplification, with destination containing new index data
 * The resulting index buffer references vertices from the original vertex buffer.
 * If the original vertex data isn't needed, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
 *
 * destination must contain enough space for the target index buffer (target_vertex_count elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * vertex_colors can be NULL; when it's not NULL, it should have float3 color in the first 12 bytes of each vertex
 * color_weight determines relative priority of color wrt position; 1.0 is a safe default
 */
meshopt_simplifyPoints :: (destination: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_vertex_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Returns the error scaling factor used by the simplifier to convert between absolute and relative extents
 *
 * Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error
 * Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error.
 */
meshopt_simplifyScale :: (vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> float32 #foreign meshopt_lib;

/**
 * Mesh stripifier
 * Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index or degenerate triangles
 * Returns the number of indices in the resulting strip, with destination containing new index data
 * For maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
 * Using restart indices can result in ~10% smaller index buffers, but on some GPUs restart indices may result in decreased performance.
 *
 * destination must contain enough space for the target index buffer, worst case can be computed with meshopt_stripifyBound
 * restart_index should be 0xffff or 0xffffffff depending on index size, or 0 to use degenerate triangles
 */
meshopt_stripify :: (destination: *u32, indices: *u32, index_count: u64, vertex_count: u64, restart_index: u32) -> u64 #foreign meshopt_lib;
meshopt_stripifyBound :: (index_count: u64) -> u64 #foreign meshopt_lib;

/**
 * Mesh unstripifier
 * Converts a triangle strip to a triangle list
 * Returns the number of indices in the resulting list, with destination containing new index data
 *
 * destination must contain enough space for the target index buffer, worst case can be computed with meshopt_unstripifyBound
 */
meshopt_unstripify :: (destination: *u32, indices: *u32, index_count: u64, restart_index: u32) -> u64 #foreign meshopt_lib;
meshopt_unstripifyBound :: (index_count: u64)-> u64 #foreign meshopt_lib;

meshopt_VertexCacheStatistics :: struct
{
	vertices_transformed: u32;
	warps_executed: u32;
	acmr: float32; /* transformed vertices / triangle count; best case 0.5, worst case 3.0, optimum depends on topology */
	atvr: float32; /* transformed vertices / vertex count; best case 1.0, worst case 6.0, optimum is 1.0 (each vertex is transformed once) */
}

/**
 * Vertex transform cache analyzer
 * Returns cache hit statistics using a simplified FIFO model
 * Results may not match actual GPU performance
 */
meshopt_analyzeVertexCache :: (indices: *u32, index_count: u64, vertex_count: u64, cache_size: u32, warp_size: u32, primgroup_size: u32) -> meshopt_VertexCacheStatistics #foreign meshopt_lib;

meshopt_VertexFetchStatistics :: struct
{
	bytes_fetched: u32;
	overfetch: float32; /* fetched bytes / vertex buffer size; best case 1.0 (each byte is fetched once) */
}

/**
 * Vertex fetch cache analyzer
 * Returns cache hit statistics using a simplified direct mapped model
 * Results may not match actual GPU performance
 */
meshopt_analyzeVertexFetch :: (indices: *u32, index_count: u64, vertex_count: u64, vertex_size: u64) -> meshopt_VertexFetchStatistics #foreign meshopt_lib;

meshopt_OverdrawStatistics :: struct
{
	pixels_covered: u32;
	pixels_shaded: u32;
	overdraw: float32; /* shaded pixels / covered pixels; best case 1.0 */
}

/**
 * Overdraw analyzer
 * Returns overdraw statistics using a software rasterizer
 * Results may not match actual GPU performance
 *
 * vertex_positions should have float3 position in the first 12 bytes of each vertex 
 */
meshopt_analyzeOverdraw :: (indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_OverdrawStatistics #foreign meshopt_lib;

meshopt_CoverageStatistics :: struct
{
	coverage: [3]float32;
	extent: float32; /* viewport size in mesh coordinates */
}

/**
 * Coverage analyzer
 * Returns coverage statistics (ratio of viewport pixels covered from each axis) using a software rasterizer
 *
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 */
meshopt_analyzeCoverage :: (indices: *u32, index_count : u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_CoverageStatistics #foreign meshopt_lib;

meshopt_Meshlet :: struct
{
	/* offsets within meshlet_vertices and meshlet_triangles arrays with meshlet data */
	vertex_offset: u32;
	triangle_offset: u32;

	/* number of vertices and triangles used in the meshlet; data is stored in consecutive range defined by offset and count */
	vertex_count: u32;
	triangle_count: u32;
}

/**
 * Meshlet builder
 * Splits the mesh into a set of meshlets where each meshlet has a micro index buffer indexing into meshlet vertices that refer to the original vertex buffer
 * The resulting data can be used to render meshes using NVidia programmable mesh shading pipeline, or in other cluster-based renderers.
 * When using buildMeshlets, vertex positions need to be provided to minimize the size of the resulting clusters.
 * When using buildMeshletsScan, for maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
 *
 * meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound
 * meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
 * meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * max_vertices and max_triangles must not exceed implementation limits (max_vertices <= 255 - not 256!, max_triangles <= 512)
 * cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency
 */
meshopt_buildMeshlets :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, max_vertices: u64, max_triangles: u64, cone_weight: float32) -> u64 #foreign meshopt_lib;
meshopt_buildMeshletsScan :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_count: u64, max_vertices: u64, max_triangles: u64) -> u64 #foreign meshopt_lib;
meshopt_buildMeshletsBound :: (index_count: u64, max_vertices: u64, max_triangles: u64) -> u64 #foreign meshopt_lib;

#if MESHOPTIMIZER_EXPERIMENTAL
{
	/**
	 * Experimental: Meshlet builder with flexible cluster sizes
	 * Splits the mesh into a set of meshlets, similarly to meshopt_buildMeshlets, but allows to specify minimum and maximum number of triangles per meshlet.
	 * Clusters between min and max triangle counts are split when the cluster size would have exceeded the expected cluster size by more than split_factor.
	 * Additionally, allows to switch to axis aligned clusters by setting cone_weight to a negative value.
	 *
	 * meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound using min_triangles (not max!)
	 * meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
	 * meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * max_vertices, min_triangles and max_triangles must not exceed implementation limits (max_vertices <= 256, max_triangles <= 512; min_triangles <= max_triangles; both min_triangles and max_triangles must be divisible by 4)
	 * cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency; additionally, cone_weight can be set to a negative value to prioritize axis aligned clusters (for raytracing) instead
	 * split_factor should be set to a non-negative value; when greater than 0, clusters that have large bounds may be split unless they are under the min_triangles threshold
	 */
	meshopt_buildMeshletsFlex :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, max_vertices: u64, min_triangles: u64, max_triangles: u64, cone_weight: float32, split_factor: float32) -> u64 #foreign meshopt_lib;

	/**
	 * Experimental: Meshlet builder that produces clusters optimized for raytracing
	 * Splits the mesh into a set of meshlets, similarly to meshopt_buildMeshlets, but optimizes cluster subdivision for raytracing and allows to specify minimum and maximum number of triangles per meshlet.
	 *
	 * meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound using min_triangles (not max!)
	 * meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
	 * meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * max_vertices, min_triangles and max_triangles must not exceed implementation limits (max_vertices <= 256, max_triangles <= 512; min_triangles <= max_triangles; both min_triangles and max_triangles must be divisible by 4)
	 * fill_weight allows to prioritize clusters that are closer to maximum size at some cost to SAH quality; 0.5 is a safe default
	 */
	meshopt_buildMeshletsSpatial :: (meshlets: *meshopt_Meshlet, meshlet_vertices: *u32, meshlet_triangles: *u8, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, max_vertices: u64, min_triangles: u64, max_triangles: *u64, fill_weight: float32) -> u64 #foreign meshopt_lib;
}

/**
 * Meshlet optimizer
 * Reorders meshlet vertices and triangles to maximize locality to improve rasterizer throughput
 *
 * meshlet_triangles and meshlet_vertices must refer to meshlet triangle and vertex index data; when buildMeshlets* is used, these
 * need to be computed from meshlet's vertex_offset and triangle_offset
 * triangle_count and vertex_count must not exceed implementation limits (vertex_count <= 256, triangle_count <= 512)
 */
meshopt_optimizeMeshlet :: (meshlet_vertices: *u32, meshlet_triangles: *u8, triangle_count: u64, vertex_count: u64) #foreign meshopt_lib;

meshopt_Bounds :: struct
{
	/* bounding sphere, useful for frustum and occlusion culling */
	center: [3]float32;
	radius: float32;

	/* normal cone, useful for backface culling */
	cone_apex: [3]float32;
	cone_axis: [3]float32;
	cone_cutoff: float32; /* = cos(angle/2) */

	/* normal cone axis and cutoff, stored in 8-bit SNORM format; decode using x/127.0 */
	cone_axis_s8: [3]s8;
	cone_cutoff_s8: s8;
}

/**
 * Cluster bounds generator
 * Creates bounding volumes that can be used for frustum, backface and occlusion culling.
 *
 * For backface culling with orthographic projection, use the following formula to reject backfacing clusters:
 *   dot(view, cone_axis) >= cone_cutoff
 *
 * For perspective projection, you can the formula that needs cone apex in addition to axis & cutoff:
 *   dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff
 *
 * Alternatively, you can use the formula that doesn't need cone apex and uses bounding sphere instead:
 *   dot(normalize(center - camera_position), cone_axis) >= cone_cutoff + radius / length(center - camera_position)
 * or an equivalent formula that doesn't have a singularity at center = camera_position:
 *   dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius
 *
 * The formula that uses the apex is slightly more accurate but needs the apex; if you are already using bounding sphere
 * to do frustum/occlusion culling, the formula that doesn't use the apex may be preferable (for derivation see
 * Real-Time Rendering 4th Edition, section 19.3).
 *
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 * index_count/3 should be less than or equal to 512 (the function assumes clusters of limited size)
 */
meshopt_computeClusterBounds :: (indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_Bounds #foreign meshopt_lib;
meshopt_computeMeshletBounds :: (meshlet_vertices: *u32, meshlet_triangles: *u8, triangle_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) -> meshopt_Bounds #foreign meshopt_lib;

/**
 * Sphere bounds generator
 * Creates bounding sphere around a set of points or a set of spheres; returns the center and radius of the sphere, with other fields of the result set to 0.
 *
 * positions should have float3 position in the first 12 bytes of each element
 * radii can be NULL; when it's not NULL, it should have a non-negative float radius in the first 4 bytes of each element
 */
meshopt_computeSphereBounds :: (positions: *float32, count: u64, positions_stride: u64, radii: *float32, radii_stride: u64) -> meshopt_Bounds #foreign meshopt_lib;

/**
 * Cluster partitioner
 * Partitions clusters into groups of similar size, prioritizing grouping clusters that share vertices or are close to each other.
 *
 * destination must contain enough space for the resulting partition data (cluster_count elements)
 * destination[i] will contain the partition id for cluster i, with the total number of partitions returned by the function
 * cluster_indices should have the vertex indices referenced by each cluster, stored sequentially
 * cluster_index_counts should have the number of indices in each cluster; sum of all cluster_index_counts must be equal to total_index_count
 * vertex_positions should have float3 position in the first 12 bytes of each vertex (or can be NULL if not used)
 * target_partition_size is a target size for each partition, in clusters; the resulting partitions may be smaller or larger
 */
meshopt_partitionClusters :: (destination: *u32, cluster_indices: *u32, total_index_count: u64, cluster_index_counts: *u32, cluster_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64, target_partition_size: u64) -> u64 #foreign meshopt_lib;

/**
 * Spatial sorter
 * Generates a remap table that can be used to reorder points for spatial locality.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 */
meshopt_spatialSortRemap :: (destination: *u32, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Experimental: Spatial sorter
 * Reorders triangles for spatial locality, and generates a new index buffer. The resulting index buffer can be used with other functions like optimizeVertexCache.
 *
 * destination must contain enough space for the resulting index buffer (index_count elements)
 * vertex_positions should have float3 position in the first 12 bytes of each vertex
 */
meshopt_spatialSortTriangles :: (destination: *u32, indices: *u32, index_count: u64, vertex_positions: *float32, vertex_count: u64, vertex_positions_stride: u64) #foreign meshopt_lib;

/**
 * Set allocation callbacks
 * These callbacks will be used instead of the default operator new/operator delete for all temporary allocations in the library.
 * Note that all algorithms only allocate memory for temporary use.
 * allocate/deallocate are always called in a stack-like order - last pointer to be allocated is deallocated first.
 */
meshopt_setAllocator :: (allocate: #type (size: u64) -> *void #c_call, deallocate: #type (ptr: *void) #c_call) #foreign meshopt_lib;

/**
 * Quantize a float in [0..1] range into an N-bit fixed point unorm value
 * Assumes reconstruction function (q / (2^N-1)), which is the case for fixed-function normalized fixed point conversion
 * Maximum reconstruction error: 1/2^(N+1)
 */
meshopt_quantizeUnorm :: inline (v: float32, N: s32) -> u32
{
	scale := cast(float32)((1 << N) - 1);

	v = ifx (v >= 0) v else 0;
	v = ifx (v <= 1) v else 1;

	return cast(u32)(v * scale + 0.5);
}

/**
 * Quantize a float in [-1..1] range into an N-bit fixed point snorm value
 * Assumes reconstruction function (q / (2^(N-1)-1)), which is the case for fixed-function normalized fixed point conversion (except early OpenGL versions)
 * Maximum reconstruction error: 1/2^N
 */
meshopt_quantizeSnorm :: inline (v: float32, N: s32) -> s32
{
	scale := cast(float)((1 << (N - 1)) - 1);

	round := ifx (v >= 0) 0.5 else -0.5;

	v = ifx (v >= -1) v else -1;
	v = ifx (v <= +1) v else +1;

	return cast(s32)(v * scale + round);
}

/**
 * Quantize a float into half-precision floating point value
 * Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
 * Representable magnitude range: [6e-5; 65504]
 * Maximum relative reconstruction error: 5e-4
 */
meshopt_quantizeHalf :: inline (v: float32) -> u16
{
	u: union { f: float32; ui: u32; } = ---;
	u.f = v;
	ui := u.ui;

	s := cast(s32)((ui >> 16) & 0x8000);
	em := cast(s32)(ui & 0x7fffffff);

	/* bias exponent and round to nearest; 112 is relative exponent bias (127-15) */
	h := (em - (112 << 23) + (1 << 12)) >> 13;

	/* underflow: flush to zero; 113 encodes exponent -14 */
	h = ifx (em < (113 << 23)) 0 else h;

	/* overflow: infinity; 143 encodes exponent 16 */
	h = ifx (em >= (143 << 23)) 0x7c00 else h;

	/* NaN; note that we convert all types of NaN to qNaN */
	h = ifx (em > (255 << 23)) 0x7e00 else h;

	return cast(u16)(s | h);
}

/**
 * Quantize a float into a floating point value with a limited number of significant mantissa bits
 * Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
 * Assumes N is in a valid mantissa precision range, which is 1..23
 */
meshopt_quantizeFloat :: inline (v: float32, N: s32) -> float32
{
	u: union { f: float32; ui: u32; } = ---;
	u.f = v;
	ui := u.ui;

	mask := cast(u32)((1 << (23 - N)) - 1);
	round := cast(u32)((1 << (23 - N)) >> 1);

	e := ui & 0x7f800000;
	rui := (ui + round) & ~mask;

	/* round all numbers except inf/nan; this is important to make sure nan doesn't overflow into -0 */
	ui = ifx (e == 0x7f800000) ui else rui;

	/* flush denormals to zero */
	ui = ifx (e == 0) 0 else ui;

	u.ui = ui;
	return u.f;
}

#scope_file

#if OS == .WINDOWS  meshopt_lib :: #library,no_dll "win/meshoptimizer";
#if OS == .MACOS    meshopt_lib :: #library,no_dll "macos/meshoptimizer";
#if OS == .LINUX    meshopt_lib :: #library,no_dll "linux/meshoptimizer";